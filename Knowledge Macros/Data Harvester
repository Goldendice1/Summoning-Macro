/**
 * Macro 1: Monster Knowledge Data Harvester (Final Subtype Property Fix)
 * Stores lore data on the SOURCE ACTOR (Sidebar) so it applies to all tokens.
 */

const controlledTokens = canvas.tokens.controlled;
if (controlledTokens.length !== 1) {
    return ui.notifications.warn("Please select exactly one token linked to the source Actor.");
}

const token = controlledTokens[0];

// Get the Source Actor from the sidebar to ensure data is shared across all copies
const actor = game.actors.get(token.document.actorId);

if (!actor) {
    return ui.notifications.error("Could not find the source actor for this token. Is it a temporary token without a sheet?");
}

// --- Helper: Parse Description Trait (No Change) ---
function parseDescriptionTrait(traitName) {
    const item = actor.items.find(i => i.name === traitName);
    if (!item) return { appearance: "", basic: "", full: "" };

    const div = document.createElement("div");
    div.innerHTML = item.system.description.value;
    
    let appearance = "";
    let basicDesc = "";
    let fullDesc = "";
    
    let firstIsItalic = false;

    const paragraphs = Array.from(div.children);

    if (paragraphs.length === 0) return { appearance: "", basic: div.innerText, full: "" };
    
    if (paragraphs[0].querySelector('em') || paragraphs[0].querySelector('i')) {
        appearance = paragraphs[0].outerHTML;
        firstIsItalic = true;
    }

    let finishedBasic = false;
    for (let i = firstIsItalic ? 1 : 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        
        if (!finishedBasic) {
            basicDesc += p.outerHTML;
            if (!p.querySelector('em') && !p.querySelector('i')) {
                finishedBasic = true;
            }
        } else {
            fullDesc += p.outerHTML;
        }
    }

    return { appearance, basic: basicDesc, full: fullDesc };
}

// --- Helper: List Trait Formatting (Immunities, Vulnerabilities, Languages) (No Change) ---
function formatListTrait(trait, labelMap) {
    if (!trait) return [];
    
    const map = labelMap || {};
    
    let value = [];
    
    // Prioritize language total if present
    if (trait.total) { 
        value = (trait.total instanceof Set) ? Array.from(trait.total) : (Array.isArray(trait.total) ? trait.total : []);
    }
    // Check general value field
    else if (Array.isArray(trait.value)) {
        value = trait.value;
    } else if (trait.value instanceof Set) {
        value = Array.from(trait.value);
    } else if (trait.value) {
        value = [trait.value];
    }
    
    let list = value.map(k => {
        return map[k] || k;
    });

    if (trait.custom && typeof trait.custom === 'string' && trait.custom.trim()) {
        list.push(trait.custom.trim());
    }
    return list.join(", ");
}

// --- Helper: Structured Resistance Formatting (DR, ERes) (No Change) ---
function formatResistance(trait) {
    const resistances = Array.isArray(trait.value) ? trait.value : [];
    if (resistances.length === 0) return null;
    
    const damageMap = CONFIG.PF1.damageTypes || {}; 

    return resistances.map(t => {
        const amt = t.amount || 0;
        
        const typesArray = Array.isArray(t.types) ? t.types : [];
        
        const mappedTypes = typesArray.map(typeKey => damageMap[typeKey] || typeKey).join(" and ");

        if (amt === 0) return null; 
        
        const output = (trait === actor.system.traits.dr) 
            ? `${amt} / ${mappedTypes}` 
            : `${amt} ${mappedTypes}`;
        
        return output.trim();
    }).filter(s => s).join(", "); 
}

// 1. Text Parsing
const descTrait = parseDescriptionTrait("Description");

const raceClassItems = actor.itemTypes.class;
const raceClass = raceClassItems ? raceClassItems[0] : null;
const typeName = raceClass ? raceClass.name : "Unknown";

// 2. Senses
const perception = actor.system.skills.per.mod;
const traits = actor.system.traits;
const sensesArray = [];

if (traits.senses.blindsight) sensesArray.push(`Blindsight ${traits.senses.blindsight} ft.`);
if (traits.senses.darkvision) sensesArray.push(`Darkvision ${traits.senses.darkvision} ft.`);
if (traits.senses.lowLightVision) sensesArray.push(`Low-Light Vision`);

if (traits.senses.custom) sensesArray.push(traits.senses.custom);

const sensesCombined = sensesArray.join(", ") || "None";


// 3. Weaknesses / Resistances
const defensesArray = [];

// DR (Structured)
if (traits.dr) {
    const drList = formatResistance(traits.dr);
    if (drList) defensesArray.push(`DR: ${drList}`);
}

// Energy Resistance (Structured)
if (traits.eres) {
    const eresList = formatResistance(traits.eres);
    if (eresList) defensesArray.push(`Energy Res: ${eresList}`);
}

// Condition Resistance (Often text or list)
if (traits.cres) {
    const cresText = typeof traits.cres === 'string' ? traits.cres : (traits.cres.value || "");
    if (cresText) defensesArray.push(`Condition Res: ${cresText}`);
}

// Condition Immunities (List)
if (traits.ci) {
    const ciList = formatListTrait(traits.ci, CONFIG.PF1.conditionTypes);
    if (ciList) defensesArray.push(`Condition Immunities: ${ciList}`);
}

// Damage Immunities (List)
if (traits.di) {
    const diList = formatListTrait(traits.di, CONFIG.PF1.damageTypes);
    if (diList) defensesArray.push(`Damage Immunities: ${diList}`);
}

// Vulnerabilities (List - Uses Damage Types)
if (traits.dv) {
    const dvList = formatListTrait(traits.dv, CONFIG.PF1.damageTypes);
    if (dvList) defensesArray.push(`Vulnerabilities: ${dvList}`);
}

// Regen / Fast Healing
if (traits.regen) defensesArray.push(`Regeneration: ${traits.regen}`);
if (traits.fastHealing) defensesArray.push(`Fast Healing: ${traits.fastHealing}`);

const defenses = defensesArray.join("<br>") || "None";


// 4. Feats (FIX: Filter specifically for item category 'feat' AND subtype 'feat')
const featList = actor.items.filter(i => 
    i.type === "feat" && 
    i.subType === "feat"
)
.map(f => f.name)
.join(", ");


// 5. Skills
const skillList = Object.entries(actor.system.skills)
    .filter(([key, sk]) => {
        const abilityMod = actor.system.abilities[sk.ability]?.mod || 0;
        return sk.mod > abilityMod || sk.rank > 0;
    })
    .map(([key, sk]) => `${CONFIG.PF1.skills[key] || key}: +${sk.mod}`)
    .join(", ");


// 6. Spells / SLAs (FINAL LOGIC APPLIED HERE)
let spellsAndSlas = "None listed.";

const spellItems = actor.items.filter(i => i.type === 'spell');

if (spellItems.length > 0) {
    // We only initialize Constant and At Will, all X/day groups will be created dynamically
    const spellGroups = {
        'Constant': [],
        'At will': [],
        'Other': [] 
    };
    
    // Determine the caster level (CL)
    let casterLevel = actor.system.attributes.spells?.primary?.cl?.total || 0; 
    if (casterLevel === 0) {
        casterLevel = Math.max(1, ...actor.itemTypes.class.map(c => c.system.levels || 0));
    }
    
    // Iterate through spells and group them
    spellItems.forEach(spell => {
        const uses = spell.system.uses;
        const name = spell.name;
        
        let key = 'Other';

        // 1. CONSTANT: Highest priority check by name convention
        if (name.toLowerCase().startsWith("constant")) {
             key = 'Constant';
        } 
        // 2. AT WILL: Check for uses.atWill or 'at will' in the usage fields
        else if (spell.system.atWill || uses.value === 'at will' || uses.per === 'at will') {
             key = 'At will';
        }
        // 3. X/DAY: Check for limited uses per day, deriving max uses from system.uses.max
        else if (uses && uses.max && uses.per === 'day') {
            const maxUses = Number(uses.max); // Use uses.max directly
            if (maxUses > 0) {
                key = `${maxUses}/day`; // Dynamic key generation
            }
        }
        
        // Add the spell name to the appropriate group, creating the group if necessary
        if (spellGroups[key]) {
            spellGroups[key].push(name);
        } else if (key !== 'Other') {
             // Dynamic key: create and add (e.g., '5/day')
             spellGroups[key] = [name];
        } else {
             // Reserve 'Other' for true non-daily or malformed data
             spellGroups['Other'].push(name);
        }
    });

    // Construct the formatted output string
    let spellsOutput = `<strong>Spell-Like Abilities</strong> (CL ${casterLevel}th)<br>`;

    // Define the strict starting order
    const fixedOrder = ['Constant', 'At will'];
    
    // Collect all present keys that are NOT Constant or At Will
    const dynamicKeys = Object.keys(spellGroups).filter(k => 
        !fixedOrder.includes(k) && 
        k.endsWith('/day') && 
        spellGroups[k].length > 0
    ).sort((a, b) => {
        // Sort X/day keys in descending order (e.g., 9/day before 1/day)
        const numA = parseInt(a.split('/')[0]);
        const numB = parseInt(b.split('/')[0]);
        return numB - numA;
    });

    // Final order of all non-empty keys
    const sortedKeys = [...fixedOrder, ...dynamicKeys, 'Other'].filter(k => 
        spellGroups[k] && spellGroups[k].length > 0
    );
    
    // Generate HTML
    sortedKeys.forEach(key => {
        // Sort the spells within each use category alphabetically
        const spellList = spellGroups[key].sort().join(', ');
        
        let formattedKey = key;
        if (key === 'Other') {
            formattedKey = 'Variable Uses / Non-Daily';
        }

        spellsOutput += `<strong>${formattedKey}</strong>â€”${spellList}<br>`;
    });

    spellsAndSlas = spellsOutput;
}


// 7. Stats
const ac = actor.system.attributes.ac;
const hp = actor.system.attributes.hp;
const bab = actor.system.attributes.bab.total;
const saves = `Fort +${actor.system.attributes.savingThrows.fort.total}, Ref +${actor.system.attributes.savingThrows.ref.total}, Will +${actor.system.attributes.savingThrows.will.total}`;
const abils = Object.entries(actor.system.abilities).map(([k, v]) => `${k.toUpperCase()} ${v.total}`).join(", ");
const statBlock = `
    <strong>AC:</strong> ${ac.normal.total}, Touch ${ac.touch.total}, Flat-footed ${ac.flatFooted.total}<br>
    <strong>HP:</strong> ${hp.max} (${actor.system.attributes.hd.total} HD)<br>
    <strong>Saves:</strong> ${saves}<br>
    <strong>BAB:</strong> +${bab}<br>
    <strong>Scores:</strong> ${abils}
`;

// 8. Ecology / Languages
const ecology = actor.items.find(i => i.name === "Ecology")?.system.description.value || "Unknown";
const languages = formatListTrait({total: actor.system.traits.languages?.total}, CONFIG.PF1.languages);


// 9. Abilities (Misc Features) (UPDATED NAME CLEANING LOGIC)
const abilitySubtypes = ["racial", "misc"];
const excludedItemNames = ["Ecology", "Tactics", "Description", "Miscellaneous Notes"];

const miscFeats = actor.items.filter(i => 
    i.type === "feat" && // Must be the Feat item category
    abilitySubtypes.includes(i.subType) && // Must have the racial or misc subtype
    !excludedItemNames.includes(i.name)
).map(i => {
    // ðŸ“¢ NEW: Strip content inside parentheses from the name for a cleaner button label
    const cleanName = i.name.replace(/\s*\([^)]*\)\s*/g, ' ').trim();
    
    return { name: cleanName, desc: i.system.description.value };
});

// Construct Data Object
const loreData = {
    appearance: descTrait.appearance || "No distinct appearance noted.",
    basic: {
        name: actor.name,
        alignment: actor.system.details.alignment,
        type: typeName,
        desc: descTrait.basic || "No description available."
    },
    fullDesc: descTrait.full || "No further description available.",
    senses: `<strong>Perception:</strong> +${perception}<br><strong>Senses:</strong> ${sensesCombined}`,
    defenses: defenses || "None",
    feats: featList || "None",
    skills: skillList || "None",
    spells: spellsAndSlas, 
    stats: statBlock,
    ecology: `<strong>Languages:</strong> ${languages}<br><strong>Ecology:</strong><br>${ecology}`,
    abilities: miscFeats
};

// Store data on the Source Actor
await actor.setFlag("world", "monsterLore", loreData);
ui.notifications.info(`Lore data stored successfully on Source Actor: ${actor.name}`);